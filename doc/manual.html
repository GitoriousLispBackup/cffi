<html>
  <head>
  <title>CFFI User Manual</title>
  </head>
  <body>
    <h1>CFFI User Manual</h1>

    <h2>Introduction</h2>

    <h3>Motivation</h3>

    <h3>Design Philosophy</h3>

    <ul>
      <li>Pointers do not carry around type information.  Instead, type
          information is supplied when pointers are dereferenced.</li>
      <li>A type safe pointer interface can be developed on top of n
          untyped one.  It is difficult to do the opposite.</li>
      <li>Functions are better than macros.  When a macro could be used
          for performance, use a compiler-macro instead.</li>
    </ul>

    <h2>Foreign Types</h2>

    <h3>Built-In Types</h3>

    <p>
    <u>Foreign Type:</u> <b>:char</b><br>
    <u>Foreign Type:</u> <b>:unsigned-char</b><br>
    <u>Foreign Type:</u> <b>:short</b><br>
    <u>Foreign Type:</u> <b>:unsigned-short</b><br>
    <u>Foreign Type:</u> <b>:int</b><br>
    <u>Foreign Type:</u> <b>:unsigned-int</b><br>
    <u>Foreign Type:</u> <b>:long</b><br>
    <u>Foreign Type:</u> <b>:unsigned-long</b><br>
    <u>Foreign Type:</u> <b>:long-long</b><br>
    <u>Foreign Type:</u> <b>:unsigned-long-long</b><br>
    </p>

    <p>
    These types correspond to the native C integer types according to
    the ABI of the system the Lisp implementation is compiled against.
    </p>

    <p>
    <u>Foreign Type:</u> <b>:int8</b><br>
    <u>Foreign Type:</u> <b>:uint8</b><br>
    <u>Foreign Type:</u> <b>:int16</b><br>
    <u>Foreign Type:</u> <b>:uint16</b><br>
    <u>Foreign Type:</u> <b>:int32</b><br>
    <u>Foreign Type:</u> <b>:uint32</b><br>
    <u>Foreign Type:</u> <b>:int64</b><br>
    <u>Foreign Type:</u> <b>:uint64</b><br>
    </p>

    <p>
    Foreign integer types of specific sizes, corresponding to the 
    C types defined in <tt>stdint.h</tt>.
    </p>

    <p>
    <u>Foreign Type:</u> <b>:size</b><br>
    <u>Foreign Type:</u> <b>:ssize</b><br>
    <u>Foreign Type:</u> <b>:ptrdiff</b><br>
 <u>Foreign Type:</u> <b>:time</b><br>
    </p>

    <p>
    Foreign integer types corresponding to the standard C types (without
    the <tt>_t</tt> suffix).
    </p>

    <p>
    <font color="green">
    I'm sure there are more of these that could be useful, let's add
    any types that can't be defined portably to this list as necessary.
    </font>
    </p>

    <p>
    <u>Foreign Type:</u> <b>:float</b><br>
    <u>Foreign Type:</u> <b>:double</b><br>
    </p>

    <p>
    The <tt>:float</tt> type represents a C <tt>float</tt> and a Lisp 
    <tt>single-float</tt>.  <tt>:double</tt> represents a C <tt>double</tt>
    and a Lisp <tt>double-float</tt>.
    </p>

    <p><u>Foreign Type:</u> <b>:pointer</b></p>

    <p>
    A foreign pointer to an object of any type, corresponding to 
    <tt>void *</tt>.
    </p>

    <p><u>Foreign Type:</u> <b>:void</b></p>

    <p>
    No type at all.  Only valid as the return type of a function.
    </p>

    <h3>Defining Typedefs</h3>

    <p>
    <u>Macro:</u> <b>defctype</b> <i>name</i> <i>type</i>
                  &amp;optional <i>documentation</i>
    </p>

    <h3>Foreign Structure Types</h3>

    <p>
    <u>Macro:</u> <b>defcstruct</b> <i>name</i> &amp;body 
                  <i>doc-options-and-slots</i>
    </p>

    <p>
    A structure slot is either simple, or aggregate.
    </p>
    
    <p>
    Simple structure slots contain a single instance of a type that
    canonicalizes to a built-in type, such as <tt>:long</tt> or 
    <tt>:pointer</tt>.
    </p>

    <p>
    Aggregate slots contain an embedded structure or union, or an array
    of objects.
    </p>

    <p>
    <u>Accessor:</u> <b>foreign-slot-value</b> <i>ptr</i> <i>type</i>
                     &amp;rest <i>slot-names</i> =&gt; <i>object</i>
    </p>

    <p>
    For simple slots, <tt>foreign-slot-value</tt> returns the value of
    the object, such as a Lisp integer or pointer.  In C, this would be
    expressed as <tt>ptr-&gt;slot</tt>.
    </p>

    <p>
    For aggregate slots, a pointer inside the structure to the beginning
    of the slot's data is returned.  In C, this would be expressed as
    <tt>&amp;ptr-&gt;slot</tt>.  This pointer and the memory it points to
    have the same extent as <i>ptr</i>.
    </p>

    <p>
    There are compiler macros for <tt>foreign-slot-value</tt> and its
    <tt>setf</tt> expansion that open code the memory access when 
    <i>type</i> and <i>slot-names</i> are constant at compile-time.
    </p>

    <p>
    <u>Macro:</u> <b>explain-foreign-slot-value</b> <i>ptr</i> <i>type</i>
                  &amp;rest <i>slot-names</i>
    </p>

    <p>
    This macro translates the slot access that would occur by calling
    <tt>FOREIGN-SLOT-VALUE</tt> with the same arguments into an equivalent
    expression in C and prints it to <tt>*STANDARD-OUTPUT*</tt>.
    </p>

    <p>Examples:</p>

<pre>
? (explain-foreign-slot-value ptr 'timeval 'tv-secs)
ptr-&gt;tv_secs

? (explain-foreign-slot-value emp 'employee 'hire-date 'tv-usecs)
emp-&gt;hire_date.tv_usecs
</pre>

    <p>
    <u>Function:</u> <b>foreign-slot-pointer</b> <i>ptr</i> <i>type</i>
                     &amp;rest <i>slot-names</i> =&gt; <i>ptr</i>
    </p>

    <p>
    Returns a pointer to a slot referred to by <i>slot-names</i>
    in a foreign object of <i>type</i> at <i>ptr</i>.  The returned
    pointer points inside the structure.  Both the pointer and the
    memory it points to have the same extent as <i>ptr</i>.
    </p>

    <p>
    For aggregate slots, this is the same value returned by
    <tt>foreign-slot-value</tt>.
    </p>

    <h4>Foreign Structure Example</h4>

<pre>
(defcstruct timeval
  (tv-sec  :long)
  (tv-usec :long))

;; A hairy structure definition that illustrates some of the rules
;; governing foreign structs.
(defcstruct person
  "A person in the employee database."
  ;; the first argument after the name may be a docstring
  :alignment :packed      ;; keyword options allowed before first slot
  (id :int)
  ;; these are defined as char[255]'s in the c code
  (first-name  :char 255)
  (last-name   :char 255)
  ;; an embedded structure
  (birthdate timeval)
  ;; a pointer to another PERSON
  (supervisor :pointer))

;;; If P is a pointer to a PERSON structure:
;; This returns p-&gt;first_name, a pointer.
(foreign-slot-value p 'person 'first-name)

;; This returns &amp;p-&gt;birthdate, a pointer.
(foreign-slot-value p 'person 'birthdate)

;; This returns p-&gt;birthdate.tv_secs as a Lisp integer.
(foreign-slot-value p 'person 'birthdate 'tv-secs)

;; The previous form is equivalent to (but may be faster than):
(foreign-slot-value
 (foreign-slot-value p 'person 'birthdate) 'timeval 'tv-secs)

;; Attempting to set the slot value of an embedded structure or
;; embedded array causes an error.  Eventually, there may be a
;; type converter that can handle this situation for some types.
;; This would be: p-&gt;birthdate = ... in C.
(setf (foreign-slot-value p 'person 'timeval) ...) =&gt; error
</pre>

    <h3>Operations on Types</h3>

    <p>
    <u>Function:</u> <b>builtin-foreign-type-p</b> <i>type</i> 
                     =&gt; <i>boolean</i>
    </p>

    <p>
    <u>Function:</u> <b>canonicalize-foreign-type</b> <i>type</i>
                     =&gt; <i>built-in-type</i>
    </p>

    <p>
    <u>Function:</u> <b>foreign-type-size</b> <i>size</i>
                     =&gt; <i>size</i>
    </p>

    <p>
    <u>Function:</u> <b>foreign-type-alignment</b> <i>type</i>
                     =&gt; <i>alignment</i>
    </p>

    <p><font color="green">
    Should these functions be part of the documented interface?  They may
    be useful for libraries built on top of CFFI---defining a type-safe
    interface on top of CFFI pointers, for example.
    </font></p>

    <h3>Allocating Foreign Objects</h3>

    <p>
    <u>Function:</u> <b>foreign-object-alloc</b> <i>type</i> 
                     &amp;optional (<i>count</i> 0) =&gt; <i>ptr</i>
    </p>

    <p>
    <u>Function:</u> <b>foreign-object-free</b> <i>ptr</i>
                     =&gt; <i>unspecified</i>
    </p>

    <p>
    <u>Macro:</u> <b>with-foreign-object</b> (<i>var</i> <i>type</i>
                  &amp;optional (<i>count</i> 1)) &amp;body <i>body</i>
    </p>

    <h2>Foreign Pointers</h2>

    <p><font color="green">
    Describe the theory of how foreign variables work---they are always
    pointers, even when accessing integer types or embedded structures.
    You cannot represent a structure by value.
    </font></p>

    <h3>Basic Pointer Operations</h3>

    <h3>Allocating Foreign Memory</h3>

    <h3>Accessing Foreign Memory</h3>

    <h2>Foreign Strings</h2>

    <h2>Foreign Functions</h2>

    <h3>Calling Foreign Functions</h3>

    <h3>Defining Foreign Functions</h3>

    <h3>Foreign Type Translators</h3>

    <p>
    Example:
    </p>

<pre>
;; Here is how the CFFI:BOOLEAN type translator is defined:
(define-type-translator boolean :in (arg result-var)
  "Type translator to convert t/nil to a C boolean."
  (values `(if ,arg 1 0) nil))

(define-type-translator boolean :result (arg result-var)
  "Type translator to convert C booleans to t/nil."
  (values `(if (zerop ,arg) nil t)))
</pre>

    <h2>Foreign Libraries</h2>

    <h2>Limitiations</h2>

    <p>
    <font size="small">
    <i>6 June 2005 / James Bielman / jamesjb at jamesjb dot com</i>
    </font>
    </p>
  </body>
</html>
